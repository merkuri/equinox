<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <!-- Ensure the simulation scales nicely on mobile devices -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Equinox Simulation</title>
  <style>
    body {
      margin: 0;
      padding: 10px;
      font-family: sans-serif;
      background: #f0f0f0;
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
    }
    #simulationContainer {
      flex: 1 1 600px;
      text-align: center;
    }
    canvas {
      border: 1px solid #ccc;
      background: #fff;
      max-width: 600px;
      width: 100%;
      height: auto;
    }
    .controls {
      margin-top: 10px;
    }
    button {
      margin: 5px;
      padding: 10px 15px;
      font-size: 16px;
      cursor: pointer;
    }
    #legend {
      flex: 1 1 250px;
      background: #fff;
      border: 1px solid #ccc;
      padding: 10px;
      margin-left: 20px;
      max-width: 250px;
      height: fit-content;
      font-size: 14px;
    }
    @media (max-width: 700px) {
      #legend {
        margin-left: 0;
        margin-top: 20px;
      }
    }
  </style>
</head>
<body>
  <div id="simulationContainer">
    <h1 id="title">Equinox Simulation</h1>
    <canvas id="simulationCanvas" width="600" height="600"></canvas>
    <div class="controls">
      <button id="togglePlay">Pause</button>
      <button id="stepButton">Step</button>
      <button id="fasterButton">Faster</button>
      <button id="slowerButton">Slower</button>
      <button id="langToggle"><span id="langFlag">ðŸ‡¦ðŸ‡±</span></button>
    </div>
  </div>
  <div id="legend">
    <h3>Legend / Commands</h3>
    <ul>
      <li><strong>Play/Pause:</strong> Toggle simulation (or tap once when running to pause).</li>
      <li><strong>Step:</strong> Advance one step when paused (or single tap when paused).</li>
      <li><strong>Faster/Slower:</strong> Adjust simulation speed.</li>
      <li><strong>Language:</strong> Switch between English and Albanian.</li>
      <li><strong>Touch (mobile):</strong>
        <ul>
          <li>Single tap while running: Pause simulation.</li>
          <li>When paused, drag the Earth to reposition its orbital phase.</li>
          <li>When paused, single tap: Advance one step.</li>
          <li>When paused, double tap: Resume simulation.</li>
        </ul>
      </li>
    </ul>
  </div>

  <script>
    // Get the canvas and context
    const canvas = document.getElementById("simulationCanvas");
    const ctx = canvas.getContext("2d");
    const width = canvas.width;
    const height = canvas.height;
    const centerX = width / 2;
    const centerY = height / 2;

    // Simulation constants
    const orbitRadius = 200;    // Earth's orbital radius (canvas pixels)
    const earthRadius = 30;     // Earth's drawn radius
    const maxTilt = 23.5 * Math.PI / 180; // 23.5Â° in radians
    // Exaggeration factor for visible N-S axis projection
    const tiltExaggeration = 1.5;

    // Simulation state variables
    // Start near spring equinox (approx. March 20/21, day ~80)
    let day = 80;
    let speed = 0.5;          // Days per frame
    let isPaused = false;
    let pauseForEquinox = false;  
    let lastEquinoxTrigger = -1;  
    let language = "en";      
    let earthSpin = 0;        // For Earthâ€™s self rotation marker

    // Helper: Convert day-of-year (1-365) to date string (e.g., "Jan 15")
    function dayToDate(dayNum) {
      const months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
      const monthDays = [31,28,31,30,31,30,31,31,30,31,30,31];
      let remaining = dayNum;
      let month = 0;
      while (remaining > monthDays[month]) {
        remaining -= monthDays[month];
        month++;
      }
      return months[month] + " " + remaining;
    }

    // Utility: Draw an arrow from (x1,y1) to (x2,y2)
    function drawArrow(x1, y1, x2, y2, color) {
      ctx.strokeStyle = color;
      ctx.fillStyle = color;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.stroke();
      // Arrowhead
      let angle = Math.atan2(y2 - y1, x2 - x1);
      let headLength = 10;
      ctx.beginPath();
      ctx.moveTo(x2, y2);
      ctx.lineTo(x2 - headLength * Math.cos(angle - Math.PI/6), y2 - headLength * Math.sin(angle - Math.PI/6));
      ctx.lineTo(x2 - headLength * Math.cos(angle + Math.PI/6), y2 - headLength * Math.sin(angle + Math.PI/6));
      ctx.lineTo(x2, y2);
      ctx.fill();
    }

    // Main drawing function
    function drawSimulation() {
      ctx.clearRect(0, 0, width, height);

      // Draw the orbital path (light gray circle)
      ctx.beginPath();
      ctx.arc(centerX, centerY, orbitRadius, 0, 2 * Math.PI);
      ctx.strokeStyle = "#aaa";
      ctx.stroke();

      // Compute Earth's orbital position
      const orbitalAngle = 2 * Math.PI * (day / 365);
      const earthX = centerX + orbitRadius * Math.cos(orbitalAngle);
      const earthY = centerY + orbitRadius * Math.sin(orbitalAngle);

      // Draw the Sun at the center: 15px radius, bright orange with rays
      ctx.beginPath();
      ctx.arc(centerX, centerY, 15, 0, 2 * Math.PI);
      ctx.fillStyle = "orange";
      ctx.fill();
      for (let i = 0; i < 8; i++) {
        const a = i * Math.PI / 4;
        const x1 = centerX + 15 * Math.cos(a);
        const y1 = centerY + 15 * Math.sin(a);
        const x2 = centerX + 25 * Math.cos(a);
        const y2 = centerY + 25 * Math.sin(a);
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.strokeStyle = "orange";
        ctx.stroke();
      }

      // Draw an arrow from Sun to Earth (sunlight direction)
      drawArrow(centerX, centerY, earthX, earthY, "green");

      // Draw Earth as a blue circle with a black outline
      ctx.beginPath();
      ctx.arc(earthX, earthY, earthRadius, 0, 2 * Math.PI);
      ctx.fillStyle = "blue";
      ctx.fill();
      ctx.strokeStyle = "black";
      ctx.stroke();

      // ---------------------------
      // Projection of the Equator & Nâ€“S Axis from an "above" view
      // ---------------------------
      // Compute effective tilt (using spring equinox at day ~80)
      // This sine function gives: 0 at day 80 (equinox), +maxTilt at summer solstice,
      // 0 at autumn equinox, and -maxTilt at winter solstice.
      let effectiveTilt = maxTilt * Math.sin(2 * Math.PI * ((day - 80) / 365));

      // Compute the direction from Earth to Sun.
      // This is the line along which the Sun's rays come.
      let sunDirectionAngle = Math.atan2(centerY - earthY, centerX - earthX);

      // --- Equator Projection ---
      // The equator plane (always perpendicular to Earth's axis) appears as:
      // â€¢ a full circle (if tilt = 0) 
      // â€¢ an ellipse when tilted, with its minor axis aligned with the Sunâ€“Earth direction.
      let eqRadiusX = earthRadius; 
      let eqRadiusY = earthRadius * Math.cos(Math.abs(effectiveTilt));
      // The ellipse is rotated by (sunDirectionAngle + 90Â°)
      let ellipseRotation = sunDirectionAngle + Math.PI / 2;
      ctx.beginPath();
      if (ctx.ellipse) {
        ctx.ellipse(earthX, earthY, eqRadiusX, eqRadiusY, ellipseRotation, 0, 2 * Math.PI);
      } else {
        // Fallback for browsers that do not support ellipse()
        ctx.save();
        ctx.translate(earthX, earthY);
        ctx.rotate(ellipseRotation);
        ctx.scale(1, Math.cos(Math.abs(effectiveTilt)));
        ctx.arc(0, 0, earthRadius, 0, 2 * Math.PI);
        ctx.restore();
      }
      ctx.strokeStyle = "white";
      ctx.lineWidth = 2;
      ctx.stroke();

      // --- Nâ€“S Axis Projection ---
      // The axis is drawn along the sun direction.
      // Its length is proportional to sin(|effectiveTilt|), exaggerated for visibility.
      let axisHalf = earthRadius * Math.sin(Math.abs(effectiveTilt)) * tiltExaggeration;
      let northX, northY, southX, southY;
      if (Math.abs(effectiveTilt) < 0.001) {
        // At equinox, the axis is a dot.
        northX = earthX;
        northY = earthY;
        southX = earthX;
        southY = earthY;
      } else if (effectiveTilt > 0) {
        // Positive effective tilt: North tilts toward the Sun.
        northX = earthX + axisHalf * Math.cos(sunDirectionAngle);
        northY = earthY + axisHalf * Math.sin(sunDirectionAngle);
        southX = earthX - axisHalf * Math.cos(sunDirectionAngle);
        southY = earthY - axisHalf * Math.sin(sunDirectionAngle);
      } else {
        // Negative effective tilt: North tilts away from the Sun.
        northX = earthX - axisHalf * Math.cos(sunDirectionAngle);
        northY = earthY - axisHalf * Math.sin(sunDirectionAngle);
        southX = earthX + axisHalf * Math.cos(sunDirectionAngle);
        southY = earthY + axisHalf * Math.sin(sunDirectionAngle);
      }
      if (axisHalf > 0.5) { // if visible
        ctx.beginPath();
        ctx.moveTo(northX, northY);
        ctx.lineTo(southX, southY);
        ctx.strokeStyle = "red";
        ctx.lineWidth = 2;
        ctx.stroke();
      } else {
        // At equinox, draw a small red dot at Earth's center
        ctx.beginPath();
        ctx.arc(earthX, earthY, 3, 0, 2 * Math.PI);
        ctx.fillStyle = "red";
        ctx.fill();
      }
      // Label the poles (if axis is visible)
      ctx.font = "bold 16px sans-serif";
      ctx.fillStyle = "red";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      if (axisHalf > 0.5) {
        ctx.fillText("N", northX, northY - 10);
        ctx.fillText("S", southX, southY + 10);
      }

      // --- Self-rotation marker along the equator ---
      // Compute marker position along the rotated ellipse using its parametric form:
      // x = cx + a*cos(phi)*cos(theta) - b*sin(phi)*sin(theta)
      // y = cy + a*cos(phi)*sin(theta) + b*sin(phi)*cos(theta)
      let a = eqRadiusX, b = eqRadiusY, theta = ellipseRotation, phi = earthSpin;
      let markerX = earthX + a * Math.cos(phi) * Math.cos(theta) - b * Math.sin(phi) * Math.sin(theta);
      let markerY = earthY + a * Math.cos(phi) * Math.sin(theta) + b * Math.sin(phi) * Math.cos(theta);
      ctx.beginPath();
      ctx.arc(markerX, markerY, 4, 0, 2 * Math.PI);
      ctx.fillStyle = "black";
      ctx.fill();

      // Display effective tilt in degrees at the top-left
      ctx.font = "16px sans-serif";
      ctx.fillStyle = "black";
      let tiltText = (language === "en") ? "Effective Tilt: " : "KÃ«nd Efektiv: ";
      tiltText += (Math.abs(effectiveTilt) * 180 / Math.PI).toFixed(1) + "Â°";
      ctx.textAlign = "left";
      ctx.fillText(tiltText, 10, 20);

      // Display current day and corresponding date
      const currentDay = (Math.floor(day) % 365) + 1;
      let dayText = (language === "en") ? "Day " : "Dita ";
      dayText += currentDay + " - " + dayToDate(currentDay);
      ctx.fillText(dayText, 10, 40);

      // If equinox pause is active, flash "Equinox!" at center
      if (pauseForEquinox) {
        ctx.font = "bold 40px sans-serif";
        ctx.fillStyle = "purple";
        ctx.textAlign = "center";
        ctx.fillText("Equinox!", width / 2, height / 2);
      }
    }

    // Main update loop
    function update() {
      if (!isPaused && !pauseForEquinox) {
        day += speed;
        if (day >= 365) day -= 365;
        // Advance self-rotation marker
        earthSpin += 0.1;
      }
      // Check for equinox (when effective tilt nears zero) and pause briefly.
      if (!pauseForEquinox && !isPaused) {
        let sineVal = Math.sin(2 * Math.PI * ((day - 80) / 365));
        if (Math.abs(sineVal) < 0.03 && lastEquinoxTrigger !== Math.floor(day)) {
          lastEquinoxTrigger = Math.floor(day);
          pauseForEquinox = true;
          setTimeout(() => { pauseForEquinox = false; }, 600);
        }
      }
      drawSimulation();
      requestAnimationFrame(update);
    }

    // Button event listeners
    document.getElementById("togglePlay").addEventListener("click", function () {
      isPaused = !isPaused;
      this.textContent = isPaused 
        ? (language === "en" ? "Resume" : "Vazhdo")
        : (language === "en" ? "Pause" : "Ndalo");
    });
    document.getElementById("stepButton").addEventListener("click", function () {
      if (isPaused) {
        day += speed +7;
        if(day >= 365) day -= 365;
        drawSimulation();
      }
    });
    document.getElementById("fasterButton").addEventListener("click", function () {
      speed *= 2;
    });
    document.getElementById("slowerButton").addEventListener("click", function () {
      speed /= 2;
    });
    document.getElementById("langToggle").addEventListener("click", function () {
      language = (language === "en") ? "al" : "en";
      document.getElementById("togglePlay").textContent = isPaused 
        ? (language === "en" ? "Resume" : "Vazhdo")
        : (language === "en" ? "Pause" : "Ndalo");
      document.getElementById("stepButton").textContent = (language === "en") ? "Step" : "Hapi";
      document.getElementById("fasterButton").textContent = (language === "en") ? "Faster" : "MÃ« shpejt";
      document.getElementById("slowerButton").textContent = (language === "en") ? "Slower" : "MÃ« ngadalÃ«";
      document.getElementById("title").textContent = (language === "en")
        ? "Equinox Simulation"
        : "Simulimi i Ekuinoksit";
      document.getElementById("langFlag").textContent = (language === "en") ? "ðŸ‡¦ðŸ‡±" : "ðŸ‡¬ðŸ‡§";
    });

    // Touch event listeners for mobile interaction
    let lastTap = 0, touchStartTime = 0, touchStartX = 0, touchStartY = 0, isDragging = false;
    canvas.addEventListener("touchstart", function (e) {
      touchStartTime = Date.now();
      const touch = e.touches[0];
      touchStartX = touch.clientX;
      touchStartY = touch.clientY;
      isDragging = false;
    }, false);
    canvas.addEventListener("touchmove", function (e) {
      if (isPaused) {
        isDragging = true;
        const touch = e.touches[0];
        const rect = canvas.getBoundingClientRect();
        const touchX = touch.clientX - rect.left;
        const touchY = touch.clientY - rect.top;
        let angle = Math.atan2(touchY - centerY, touchX - centerX);
        if (angle < 0) angle += 2 * Math.PI;
        day = (angle / (2 * Math.PI)) * 365;
        e.preventDefault();
      }
    }, false);
    canvas.addEventListener("touchend", function (e) {
      const now = Date.now();
      if (!isDragging) {
        if (now - lastTap < 300) {
          // Double tap when paused: resume simulation
          if (isPaused) {
            isPaused = false;
            document.getElementById("togglePlay").textContent = (language === "en") ? "Pause" : "Ndalo";
          }
          lastTap = 0;
        } else {
          // Single tap: if running, pause; if paused, step.
          if (!isPaused) {
            isPaused = true;
            document.getElementById("togglePlay").textContent = (language === "en") ? "Resume" : "Vazhdo";
          } else {
            day += speed;
            if(day >= 365) day -= 365;
            drawSimulation();
          }
          lastTap = now;
        }
      }
    }, false);

    // Start the simulation loop
    update();
  </script>
</body>
</html>

